// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package tutorial

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type EventsType string

const (
	EventsTypeTASKCOMPLETIONTIME EventsType = "TASK_COMPLETION_TIME"
)

func (e *EventsType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventsType(s)
	case string:
		*e = EventsType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventsType: %T", src)
	}
	return nil
}

type NullEventsType struct {
	EventsType EventsType `json:"EventsType"`
	Valid      bool       `json:"valid"` // Valid is true if EventsType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventsType) Scan(value interface{}) error {
	if value == nil {
		ns.EventsType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventsType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventsType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventsType), nil
}

type MetricsType string

const (
	MetricsTypeTOTALNUMDOJOWORKERS       MetricsType = "TOTAL_NUM_DOJO_WORKERS"
	MetricsTypeTOTALNUMCOMPLETEDTASKS    MetricsType = "TOTAL_NUM_COMPLETED_TASKS"
	MetricsTypeTOTALNUMTASKRESULTS       MetricsType = "TOTAL_NUM_TASK_RESULTS"
	MetricsTypeAVERAGETASKCOMPLETIONTIME MetricsType = "AVERAGE_TASK_COMPLETION_TIME"
)

func (e *MetricsType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MetricsType(s)
	case string:
		*e = MetricsType(s)
	default:
		return fmt.Errorf("unsupported scan type for MetricsType: %T", src)
	}
	return nil
}

type NullMetricsType struct {
	MetricsType MetricsType `json:"MetricsType"`
	Valid       bool        `json:"valid"` // Valid is true if MetricsType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMetricsType) Scan(value interface{}) error {
	if value == nil {
		ns.MetricsType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MetricsType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMetricsType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MetricsType), nil
}

type TaskResultStatus string

const (
	TaskResultStatusINPROGRESS TaskResultStatus = "IN_PROGRESS"
	TaskResultStatusCOMPLETED  TaskResultStatus = "COMPLETED"
	TaskResultStatusINVALID    TaskResultStatus = "INVALID"
)

func (e *TaskResultStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskResultStatus(s)
	case string:
		*e = TaskResultStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskResultStatus: %T", src)
	}
	return nil
}

type NullTaskResultStatus struct {
	TaskResultStatus TaskResultStatus `json:"TaskResultStatus"`
	Valid            bool             `json:"valid"` // Valid is true if TaskResultStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskResultStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TaskResultStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskResultStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskResultStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskResultStatus), nil
}

type TaskStatus string

const (
	TaskStatusINPROGRESS TaskStatus = "IN_PROGRESS"
	TaskStatusCOMPLETED  TaskStatus = "COMPLETED"
	TaskStatusEXPIRED    TaskStatus = "EXPIRED"
)

func (e *TaskStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskStatus(s)
	case string:
		*e = TaskStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskStatus: %T", src)
	}
	return nil
}

type NullTaskStatus struct {
	TaskStatus TaskStatus `json:"TaskStatus"`
	Valid      bool       `json:"valid"` // Valid is true if TaskStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TaskStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskStatus), nil
}

type TaskType string

const (
	TaskTypeCODEGENERATION TaskType = "CODE_GENERATION"
	TaskTypeDIALOGUE       TaskType = "DIALOGUE"
	TaskTypeTEXTTOIMAGE    TaskType = "TEXT_TO_IMAGE"
	TaskTypeTEXTTOTHREED   TaskType = "TEXT_TO_THREE_D"
)

func (e *TaskType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TaskType(s)
	case string:
		*e = TaskType(s)
	default:
		return fmt.Errorf("unsupported scan type for TaskType: %T", src)
	}
	return nil
}

type NullTaskType struct {
	TaskType TaskType `json:"TaskType"`
	Valid    bool     `json:"valid"` // Valid is true if TaskType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskType) Scan(value interface{}) error {
	if value == nil {
		ns.TaskType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TaskType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TaskType), nil
}

type ApiKey struct {
	ID          string           `db:"id" json:"id"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Key         string           `db:"key" json:"key"`
	IsDelete    bool             `db:"is_delete" json:"is_delete"`
	MinerUserID string           `db:"miner_user_id" json:"miner_user_id"`
}

type DojoWorker struct {
	ID                 string           `db:"id" json:"id"`
	CreatedAt          pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	WalletAddress      string           `db:"wallet_address" json:"wallet_address"`
	ChainID            string           `db:"chain_id" json:"chain_id"`
	CurrentStakeAmount pgtype.Float8    `db:"current_stake_amount" json:"current_stake_amount"`
}

type Event struct {
	ID         string           `db:"id" json:"id"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Type       EventsType       `db:"type" json:"type"`
	EventsData []byte           `db:"events_data" json:"events_data"`
}

type ExternalUser struct {
	ID         string           `db:"id" json:"id"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Name       string           `db:"name" json:"name"`
	Email      string           `db:"email" json:"email"`
	IsVerified bool             `db:"is_verified" json:"is_verified"`
}

type Metric struct {
	ID          string           `db:"id" json:"id"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Type        MetricsType      `db:"type" json:"type"`
	MetricsData []byte           `db:"metrics_data" json:"metrics_data"`
}

type MinerUser struct {
	ID               string           `db:"id" json:"id"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Hotkey           string           `db:"hotkey" json:"hotkey"`
	Email            pgtype.Text      `db:"email" json:"email"`
	OrganizationName pgtype.Text      `db:"organizationName" json:"organizationName"`
}

type SubscriptionKey struct {
	ID          string           `db:"id" json:"id"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Key         string           `db:"key" json:"key"`
	IsDelete    bool             `db:"is_delete" json:"is_delete"`
	MinerUserID string           `db:"miner_user_id" json:"miner_user_id"`
}

type Task struct {
	ID          string           `db:"id" json:"id"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	ExpireAt    pgtype.Timestamp `db:"expire_at" json:"expire_at"`
	Title       string           `db:"title" json:"title"`
	Body        string           `db:"body" json:"body"`
	Type        TaskType         `db:"type" json:"type"`
	TaskData    []byte           `db:"task_data" json:"task_data"`
	Status      TaskStatus       `db:"status" json:"status"`
	MaxResults  int32            `db:"max_results" json:"max_results"`
	NumResults  int32            `db:"num_results" json:"num_results"`
	NumCriteria int32            `db:"num_criteria" json:"num_criteria"`
	TotalReward pgtype.Float8    `db:"total_reward" json:"total_reward"`
	MinerUserID pgtype.Text      `db:"miner_user_id" json:"miner_user_id"`
}

type TaskResult struct {
	ID              string           `db:"id" json:"id"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Status          TaskResultStatus `db:"status" json:"status"`
	ResultData      []byte           `db:"result_data" json:"result_data"`
	TaskID          string           `db:"task_id" json:"task_id"`
	WorkerID        string           `db:"worker_id" json:"worker_id"`
	StakeAmount     pgtype.Float8    `db:"stake_amount" json:"stake_amount"`
	PotentialReward pgtype.Float8    `db:"potential_reward" json:"potential_reward"`
	PotentialLoss   pgtype.Float8    `db:"potential_loss" json:"potential_loss"`
	FinalisedReward pgtype.Float8    `db:"finalised_reward" json:"finalised_reward"`
	FinalisedLoss   pgtype.Float8    `db:"finalised_loss" json:"finalised_loss"`
}

type WorkerPartner struct {
	ID                   string           `db:"id" json:"id"`
	CreatedAt            pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	MinerSubscriptionKey string           `db:"miner_subscription_key" json:"miner_subscription_key"`
	WorkerID             string           `db:"worker_id" json:"worker_id"`
	IsDeleteByMiner      bool             `db:"is_delete_by_miner" json:"is_delete_by_miner"`
	IsDeleteByWorker     bool             `db:"is_delete_by_worker" json:"is_delete_by_worker"`
	Name                 pgtype.Text      `db:"name" json:"name"`
}
